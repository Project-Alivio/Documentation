{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Alivio Documentation This site is meant for members of the Project Alivio Software team to document the application for future and current members. You can view the Alivio MHEAL Site here . Contact Questions or concerns? Contact Alivio's current software lead Swaraj (swarajy@umich.edu).","title":"Home"},{"location":"#alivio-documentation","text":"This site is meant for members of the Project Alivio Software team to document the application for future and current members. You can view the Alivio MHEAL Site here .","title":"Alivio Documentation"},{"location":"#contact","text":"Questions or concerns? Contact Alivio's current software lead Swaraj (swarajy@umich.edu).","title":"Contact"},{"location":"architecture/","text":"Overall Architecture and Flow of Data Our app's overall architecture can best be summarized by this diagram: Certain parts are explained below later in this section, while others (like AWS) have their own section. At a high level, the flow of data throughout the app can best be described as follows: When a user interacts with the UX, they are interacting front end build using JavaScript and React. The entire app, from the front end, to the back end and database, is hosted on AWS. The front and back end are bundled up into a Docker image that is run on an AWS service called ElasticBeanstalk. If necessary, the JavaScript then makes an API call using the fetch function to our REST API written in Python and Flask. Before the API call even hits the desired endpoint, a series of intermediary steps occur. First, the API call is intercepted by a service worker. If the service worker already has a token cached, it hands the call to the API endpoint. If a token is not cached, a call to a third party API is made to acquire a valid token from an authentication and authorization service called Auth0. With the token, the service worker now proceeds to the API endpoint. If the network is offline, the service worker returns a default offline page to render with cached data. When the API call hits the appropriate endpoint, it reaches the corresponding Flask route decorator (specified with the @ symbol). Within the API endpoint function that is executed, a database query is run. In order to execute a query on a database hosted in the cloud on AWS, a Python library called boto3 is used to make a connection to the database. Database Schema A database schema defines data organization within a relational database. In this section, we describe the Alivio Database Schema. For any column that has a timestamp data type, those timestamps are stored in the UTC timezone. When times are actually rendered on the front end, libraries that we use such as moment.js convert from UTC to local time. In the patient table, here are some specific columns that we would like to callout in order to explain how they store data. Stay Duration Stores a timestamp of when the patient card was added. In the fornt end, this timestamp is subtracted from the current time to produce the stay duration in days as an integer. Ulcer Map Front and back and Back Stores a big string of pairs delimited by the | character. The pairs are delimited by commas, so the entire string looks something like this: <x1>,<y1>|<x2>,<y2>| . Each pair holds the values <x>,<y> , where x represents the x coordinate of the ulcer dot on the image and y represents the corresponding y coordinate. Average Turn Time Stores a varchar(500). Stores the total time a patient has been in the ICU and the number of turns seperated by a comma Following the format <total-time>,<turns> eg: 1005,6 When this data is called, the string can be parsed and the average turn time can be calculated by doing total-time / turns Braden History Stores a big string of pairs delimited by semicolons. The pairs are delimited by commas. The string follows this format: <timestamp>,<braden-value>;<timestamp-2>,<braden-value-2>; ... ;<timestamp-n>,<braden-value-n>; Service Workers We use a service worker API in our application. A service worker is a proxy server that sits between our web app, the browser and the network (when it is available). The purpose of the service worker is to create an offline user experience for our application. Because our app is meant to be used in an ICU, we must try and maintain 100% uptime for our application. A service worker helps us achieve this goal. The code for the service worker can be found in the file: /serviceWorker.js . As of the time of writing, it is in the archive_token branch and hasn't been merged into main. How the service worker functions The service worker runs in a different thread than the main application, and caches application data. When internet connection is disrupted cached assets can be used to maintain functionality of our application. Cached assets can be used for offline functionality but also to speed up the app performance in general. The service worker will intercept API calls that the app makes and in the event that it has cached the assets that are being requested, it will stop the call early and provide the response instead. The service worker uses two types of caches. A static and a dynamic cache. We use the dynamic cache to store data that changes such as patient data (patient cards). We use the static cache to store app assets Token Authentication Token-based authentication is a protocol which allows users to verify their identity, and in return receive a unique access token. During the lifetime of the token, users can then access different parts of our app. Please read the link about token authetication before proceeding. Project Alivio uses token authentication. To autheticate into the app, a user will type in a username and password that will be verified based on info stored in the database. If the verfication proceeds, the login API endpoint will make a request for a token to an Auth0 API (see the get_token function in middleware/token_auth.py ) and the service worker will cache it. This token allows users to interact with our API endpoints and therefore our database. The purpose of token authentication is to create a secure system for users to access sensitive patient data. Once a user logs in, the user has a 24 hr token that will allow them to use the app fully. After 24 hours or a logout, the token expires. Code for token authentication can be found in api/login.py and middlerware/token_auth.py . File Structure Here is the output of the command: $ tree -I \"env\" with explanation. . \u251c\u2500\u2500 api // back-end \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 braden.py \u2502 \u251c\u2500\u2500 clock.py \u2502 \u251c\u2500\u2500 index.py \u2502 \u2514\u2500\u2500 stats.py \u251c\u2500\u2500 application.py \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 alivio \u251c\u2500\u2500 client // front-end \u2502 \u251c\u2500\u2500 addPatient.jsx \u2502 \u251c\u2500\u2500 bradenInputs.jsx \u2502 \u251c\u2500\u2500 calculator.jsx \u2502 \u251c\u2500\u2500 clock.jsx \u2502 \u251c\u2500\u2500 feedbackForm.jsx \u2502 \u251c\u2500\u2500 helpers.js \u2502 \u251c\u2500\u2500 home.jsx \u2502 \u251c\u2500\u2500 main.jsx \u2502 \u251c\u2500\u2500 patientCard.jsx \u2502 \u251c\u2500\u2500 patientStats.jsx \u2502 \u251c\u2500\u2500 stats.jsx \u2502 \u251c\u2500\u2500 styles \u2502 \u2502 \u251c\u2500\u2500 calculator.css \u2502 \u2502 \u251c\u2500\u2500 card.css \u2502 \u2502 \u251c\u2500\u2500 clock.css \u2502 \u2502 \u251c\u2500\u2500 home.css \u2502 \u2502 \u2514\u2500\u2500 stats.css \u2502 \u2514\u2500\u2500 ulcerMap.jsx \u251c\u2500\u2500 config.py \u251c\u2500\u2500 model.py \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 setup.py \u251c\u2500\u2500 sql \u2502 \u2514\u2500\u2500 schema.sql \u251c\u2500\u2500 static // store static assets such as images \u2502 \u251c\u2500\u2500 assets \u2502 \u2502 \u251c\u2500\u2500 ulcer_map_back.png \u2502 \u2502 \u2514\u2500\u2500 ulcer_map_front.png \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u251c\u2500\u2500 ulcer_map_back.png \u2502 \u2502 \u2514\u2500\u2500 ulcer_map_front.png \u2502 \u2514\u2500\u2500 js \u2502 \u2514\u2500\u2500 bundle.js.map \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2514\u2500\u2500 webpack.config.js 10 directories, 38 files","title":"Application Architecture"},{"location":"architecture/#overall-architecture-and-flow-of-data","text":"Our app's overall architecture can best be summarized by this diagram: Certain parts are explained below later in this section, while others (like AWS) have their own section. At a high level, the flow of data throughout the app can best be described as follows: When a user interacts with the UX, they are interacting front end build using JavaScript and React. The entire app, from the front end, to the back end and database, is hosted on AWS. The front and back end are bundled up into a Docker image that is run on an AWS service called ElasticBeanstalk. If necessary, the JavaScript then makes an API call using the fetch function to our REST API written in Python and Flask. Before the API call even hits the desired endpoint, a series of intermediary steps occur. First, the API call is intercepted by a service worker. If the service worker already has a token cached, it hands the call to the API endpoint. If a token is not cached, a call to a third party API is made to acquire a valid token from an authentication and authorization service called Auth0. With the token, the service worker now proceeds to the API endpoint. If the network is offline, the service worker returns a default offline page to render with cached data. When the API call hits the appropriate endpoint, it reaches the corresponding Flask route decorator (specified with the @ symbol). Within the API endpoint function that is executed, a database query is run. In order to execute a query on a database hosted in the cloud on AWS, a Python library called boto3 is used to make a connection to the database.","title":"Overall Architecture and Flow of Data"},{"location":"architecture/#database-schema","text":"A database schema defines data organization within a relational database. In this section, we describe the Alivio Database Schema. For any column that has a timestamp data type, those timestamps are stored in the UTC timezone. When times are actually rendered on the front end, libraries that we use such as moment.js convert from UTC to local time. In the patient table, here are some specific columns that we would like to callout in order to explain how they store data. Stay Duration Stores a timestamp of when the patient card was added. In the fornt end, this timestamp is subtracted from the current time to produce the stay duration in days as an integer. Ulcer Map Front and back and Back Stores a big string of pairs delimited by the | character. The pairs are delimited by commas, so the entire string looks something like this: <x1>,<y1>|<x2>,<y2>| . Each pair holds the values <x>,<y> , where x represents the x coordinate of the ulcer dot on the image and y represents the corresponding y coordinate. Average Turn Time Stores a varchar(500). Stores the total time a patient has been in the ICU and the number of turns seperated by a comma Following the format <total-time>,<turns> eg: 1005,6 When this data is called, the string can be parsed and the average turn time can be calculated by doing total-time / turns Braden History Stores a big string of pairs delimited by semicolons. The pairs are delimited by commas. The string follows this format: <timestamp>,<braden-value>;<timestamp-2>,<braden-value-2>; ... ;<timestamp-n>,<braden-value-n>;","title":"Database Schema"},{"location":"architecture/#service-workers","text":"We use a service worker API in our application. A service worker is a proxy server that sits between our web app, the browser and the network (when it is available). The purpose of the service worker is to create an offline user experience for our application. Because our app is meant to be used in an ICU, we must try and maintain 100% uptime for our application. A service worker helps us achieve this goal. The code for the service worker can be found in the file: /serviceWorker.js . As of the time of writing, it is in the archive_token branch and hasn't been merged into main.","title":"Service Workers"},{"location":"architecture/#how-the-service-worker-functions","text":"The service worker runs in a different thread than the main application, and caches application data. When internet connection is disrupted cached assets can be used to maintain functionality of our application. Cached assets can be used for offline functionality but also to speed up the app performance in general. The service worker will intercept API calls that the app makes and in the event that it has cached the assets that are being requested, it will stop the call early and provide the response instead. The service worker uses two types of caches. A static and a dynamic cache. We use the dynamic cache to store data that changes such as patient data (patient cards). We use the static cache to store app assets","title":"How the service worker functions"},{"location":"architecture/#token-authentication","text":"Token-based authentication is a protocol which allows users to verify their identity, and in return receive a unique access token. During the lifetime of the token, users can then access different parts of our app. Please read the link about token authetication before proceeding. Project Alivio uses token authentication. To autheticate into the app, a user will type in a username and password that will be verified based on info stored in the database. If the verfication proceeds, the login API endpoint will make a request for a token to an Auth0 API (see the get_token function in middleware/token_auth.py ) and the service worker will cache it. This token allows users to interact with our API endpoints and therefore our database. The purpose of token authentication is to create a secure system for users to access sensitive patient data. Once a user logs in, the user has a 24 hr token that will allow them to use the app fully. After 24 hours or a logout, the token expires. Code for token authentication can be found in api/login.py and middlerware/token_auth.py .","title":"Token Authentication"},{"location":"architecture/#file-structure","text":"Here is the output of the command: $ tree -I \"env\" with explanation. . \u251c\u2500\u2500 api // back-end \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 braden.py \u2502 \u251c\u2500\u2500 clock.py \u2502 \u251c\u2500\u2500 index.py \u2502 \u2514\u2500\u2500 stats.py \u251c\u2500\u2500 application.py \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 alivio \u251c\u2500\u2500 client // front-end \u2502 \u251c\u2500\u2500 addPatient.jsx \u2502 \u251c\u2500\u2500 bradenInputs.jsx \u2502 \u251c\u2500\u2500 calculator.jsx \u2502 \u251c\u2500\u2500 clock.jsx \u2502 \u251c\u2500\u2500 feedbackForm.jsx \u2502 \u251c\u2500\u2500 helpers.js \u2502 \u251c\u2500\u2500 home.jsx \u2502 \u251c\u2500\u2500 main.jsx \u2502 \u251c\u2500\u2500 patientCard.jsx \u2502 \u251c\u2500\u2500 patientStats.jsx \u2502 \u251c\u2500\u2500 stats.jsx \u2502 \u251c\u2500\u2500 styles \u2502 \u2502 \u251c\u2500\u2500 calculator.css \u2502 \u2502 \u251c\u2500\u2500 card.css \u2502 \u2502 \u251c\u2500\u2500 clock.css \u2502 \u2502 \u251c\u2500\u2500 home.css \u2502 \u2502 \u2514\u2500\u2500 stats.css \u2502 \u2514\u2500\u2500 ulcerMap.jsx \u251c\u2500\u2500 config.py \u251c\u2500\u2500 model.py \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 setup.py \u251c\u2500\u2500 sql \u2502 \u2514\u2500\u2500 schema.sql \u251c\u2500\u2500 static // store static assets such as images \u2502 \u251c\u2500\u2500 assets \u2502 \u2502 \u251c\u2500\u2500 ulcer_map_back.png \u2502 \u2502 \u2514\u2500\u2500 ulcer_map_front.png \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u251c\u2500\u2500 ulcer_map_back.png \u2502 \u2502 \u2514\u2500\u2500 ulcer_map_front.png \u2502 \u2514\u2500\u2500 js \u2502 \u2514\u2500\u2500 bundle.js.map \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2514\u2500\u2500 webpack.config.js 10 directories, 38 files","title":"File Structure"},{"location":"aws/","text":"Overview Alivio primarily uses the following AWS Services: ECR: Elastic Container Registry for storing Docker Images. EC2: An elastic load balancer to handle changing user demand. RDS: A relational database service. WAF: A web application firewall for security. This document covers the following: Deploying the application to the ECR (Elastic Container Registry) and loading it into the ELB (Elastic Load Balancer) The web application firewall (WAF) Deploying to ECR, pushing to ELB. To redeploy the application on AWS, follow the steps in the section below: The main branch of the application has a file named deploy-image.sh running this script will push the docker image to ECR. If the script stops working or isn\u2019t available for whatever reason, the commands for the script can be found at the AWS Management Console. Google > AWS Management Console > Services > ECR > Repositories > alivio-testing -> View Push Commands Now do the following : Run the script: $ bash deploy-image.sh Go to: AWS Management Console > Elastic Beanstalk > Environments > environment_name (e.g Aliviotest1-env) > Click Upload and Deploy > Select Dockerrun.aws.json Done! WAF (End to End Encryption) This section details how to add a new ACL (Access Control List) and link it to an existing application. It requires the following steps already be completed: A docker image has been created and pushed to ECR, and that it is also on an ELB. There is a ALB (Application Load Balancer) that is linked to an EC2 Instance. To add more rules to the ACL : Google > AWS Management Console > Services > WAF and Shield > Web ACL\u2019s > Region=US-east-2 (ohio) Currently the only ACL is alivioTestingACL, in the future if we ever need to make a new ACL (development vs live use), follow these steps: Go to the ACL: google > AWS Management Console > Services > WAF and Shield > Web ACL\u2019s, click: create web ACL, use the following fields: Resource Type: Regional resources (we\u2019re using an ALB) Region: US-East (Ohio) Associated AWS resources = <EC2-instance-name> (i) The console states this step is optional in the start-up process, it is NOT optional, here you must link your ACL to the EC2 instance. Without this step the ACL will not stand in-front of any requests for the ALB. (ii) If (i) doesn\u2019t work, it should also be possible to go to Services > EC2 > instance_name > security groups and then link the ACL there (although I didn\u2019t have success with this method at the time of writing). Once the ACL has been generated, add any rules you need, the testing-build uses the following. A regional rule (only allow access from Guatemala, US) Rule for SQL injections General AWS safety rules Done!","title":"AWS"},{"location":"aws/#overview","text":"Alivio primarily uses the following AWS Services: ECR: Elastic Container Registry for storing Docker Images. EC2: An elastic load balancer to handle changing user demand. RDS: A relational database service. WAF: A web application firewall for security. This document covers the following: Deploying the application to the ECR (Elastic Container Registry) and loading it into the ELB (Elastic Load Balancer) The web application firewall (WAF)","title":"Overview"},{"location":"aws/#deploying-to-ecr-pushing-to-elb","text":"To redeploy the application on AWS, follow the steps in the section below: The main branch of the application has a file named deploy-image.sh running this script will push the docker image to ECR. If the script stops working or isn\u2019t available for whatever reason, the commands for the script can be found at the AWS Management Console. Google > AWS Management Console > Services > ECR > Repositories > alivio-testing -> View Push Commands Now do the following : Run the script: $ bash deploy-image.sh Go to: AWS Management Console > Elastic Beanstalk > Environments > environment_name (e.g Aliviotest1-env) > Click Upload and Deploy > Select Dockerrun.aws.json Done!","title":"Deploying to ECR, pushing to ELB."},{"location":"aws/#waf-end-to-end-encryption","text":"This section details how to add a new ACL (Access Control List) and link it to an existing application. It requires the following steps already be completed: A docker image has been created and pushed to ECR, and that it is also on an ELB. There is a ALB (Application Load Balancer) that is linked to an EC2 Instance. To add more rules to the ACL : Google > AWS Management Console > Services > WAF and Shield > Web ACL\u2019s > Region=US-east-2 (ohio) Currently the only ACL is alivioTestingACL, in the future if we ever need to make a new ACL (development vs live use), follow these steps: Go to the ACL: google > AWS Management Console > Services > WAF and Shield > Web ACL\u2019s, click: create web ACL, use the following fields: Resource Type: Regional resources (we\u2019re using an ALB) Region: US-East (Ohio) Associated AWS resources = <EC2-instance-name> (i) The console states this step is optional in the start-up process, it is NOT optional, here you must link your ACL to the EC2 instance. Without this step the ACL will not stand in-front of any requests for the ALB. (ii) If (i) doesn\u2019t work, it should also be possible to go to Services > EC2 > instance_name > security groups and then link the ACL there (although I didn\u2019t have success with this method at the time of writing). Once the ACL has been generated, add any rules you need, the testing-build uses the following. A regional rule (only allow access from Guatemala, US) Rule for SQL injections General AWS safety rules Done!","title":"WAF (End to End Encryption)"},{"location":"components/","text":"Overview The following section will discuss the various key components to Alivio's app. At a high level, we will discuss the functionality of each component, their necessity from a user perspective, and how they were built. Before reading this section, we would highly recommend reading the Technologies section to get a feel for which languages and libraries were used in creating the components. Alivio's app serves as a pressure ulcer risk management system. It seeks to help nurses understand the incidence of pressure ulcers in the ICU on a patient-by-patient basis as well as on a population-level basis. Furthermore, the app allows nurses to understand and synthesize patient data relavent to pressure ulcers in order to better inform their decision making when tending to patients and organizing their workflow. Patient Card In order to give nurses a \"patient-by-patient\" view, each patient is displayed as a \"card\". Each card can be expanded by clicking the gray arrow at the bottom-center of the card in order to view pressure ulcer related data specfic to the patient. Each patient is uniquely identified by their bed number and ward, which is displayed when the card is both expanded and closed. When expanding the card, a nurse can see the following pieces of data, which were all identified as relavent to pressure ulcers by SAIMER: Age Sex Weight Duration of stay in the ICU Braden Scale value Exact date and time when the patient was last turned Average turn time (i.e. on average, what is the time since the patient was last turned) Notes taken by the nurse These values can be edited by clicking the pencil icon in the top right corner of the expanded portion of the card. The code for the patient card component can be seen in client/patientCard.jsx . The styling is done in client/styles/card.css , and this MUI component. Most of the backend functionalities pertaining to rendering the cards, updating the card's values, adding a new card, etc. live in api/index.py . Patient Card Management In order to add and delete patient cards, a nurse should first click the pencil icon at the top center of the entire screen (above the fist card displayed, next to the search bar and sorting features) to perform any additions or deletions. To add a new patient, the nurse can click the plus icon and a dialog will pop up listing all the information that will be needed to generate a new card. To delete a patient, the nurse should click the red trash can icon at the top right of the desired patient card. The add patient functionality code can be found in client/addPatient.jsx and all other necessary functionalities for these two components can be found in client/patientCard.jsx . To create the add patient component, MUI's Dialog and DateTimePicker components were used. Clock One of the key features on our patient card is the clock mounted to the right of the patient's bed and ward. Here are they key functionalities of clock: At the center of the ring that represents the clock, the time since the patient was last turned is displayed. The ring \"fills up\" with solid color to denote how close the time to turn the patient again is. When the ring is less than 1/3 full it is green, between 1/3 and 2/3 full it is orange, and more than 2/3 full it is red. The ring fills up at a rate proportional to the patient's Braden Scale value. Based on numbers given to us by SAIMER, a patient at high risk for pressure ulcers needs to be turned every two hours, whereas for medium risk the time is three hours and low risk is two hours. Risk categorization is determined by the creators of the Braden Scale; further information can be found in the Braden Scale link in the card section above. To reset the clock back to 0h0m (i.e. a patient has been turned), a nurse should double tap inside the ring, as indicated by the text below the time. In the event that a nurse accidentally double taps the clock, they can reset back to the original time displayed by double tapping again. There is a thirty second window built in to perform this reset. This clock is a key feature in bringing rich visuals to the app and helping nurses understand where all patients stand at any given moment regarding their turn timing. All front end work for the clock can be found in client/clock.jsx and client/styles/clock.css ; since the clock is a child component of the patient card, state is lifted upwards to the patient card component and therefore other clock functionalities can also be found in client/patientCard.jsx . All backend work currently lives in api/clock.py . The ring component was built using a React package called react-circular-progressbar . Ulcer Map When the patient card is expanded, a diagram of two human bodies is displayed below all the data by default. These two diagrams serve as the Ulcer Map component, which is a way for nurses to mark where the given patient has ulcers on their body. In order to mark the ulcers, the nurse would have to click the pencil icon to trigger edit mode and then tap the area of the body where the ulcer is. Then, a red circle will appear there to denote it. If a nurse would like to remove that circle, they can tap the circle and it will disappear. The Ulcer Map is a child component of the patient card and all of its front end code can be found in client/ulcerMap.jsx (as well as client/patientCard.jsx ). The design of the component was inspired by this StackOverflow post and corresponding CodeSandbox. Info Using a CodeSandbox for frontend Javascript work can be really helpful. It provides a way for you to write some code and see how it works in an isolated environment without needing any IDE set up on your end. Trends When the patient card is expanded, there are two icons in the top right corner of the expanded portion when in the default state: a pencil icon (edit mode) and a trend icon. When the trend icon is clicked on, the Ulcer Map changes to the Trends component. When the Trends component is displayed, the trenc icon toggles to a human body icon to toggle back to the Ulcer Map. The Trends component displays a graph of how the patient's Braden Scale value changes over time (tracked in the unit of days). This allows for a nurse to gain a better understanding of a patient's progression regarding pressure ulcers in a visual way. The Trends component is a child component of the patient card and all of its front end code can be found in client/patientStats.jsx (as well as client/patientCard.jsx ). The React graphing library Victory was used to make the chart. Braden Scale Calculator In order to actually calculate a patient's Braden Scale value, the Braden Scale Calculator component provides an interface to input the specific values for each category in the scale. The calculator icon, which appears next to the Braden Scale value when edit mode is on, will display the caclulator when clicked. All front end code can be found in client/calculator.jsx , which serves as the base dialog pop up for the component, and client/bradenInputs.jsx . All backend code can be found in api/braden.py . In order to create this component, MUI's Dialog and ToggleButtonGroup components were used. Info If you haven't already learned about what the Braden Scale is at this point, please take the time to do some research and understand it, as it is a key part of our app. View Management In order to make the interface of all the patient cards more manageable, we provide three different ways to focus in on a subset of patients based on specific characteristics. Code for the search bar and sorting can be found in client/home.jsx and code for filtering can be found in client/filtering.jsx . Search Bar A nurse can search for specific patient cards based on the notes in their cards. Sorting A nurse can sort the cards based on four different criteria: Braden Scale value. This is the default way the cards are sorted, as it places higher risk patients (those with lower Braden Scale values) at the top of the list. Bed. This sorts the cards in ascending order by bed id. Time since last turn. This allows for nurses to see which patients were turned the longest time ago at the top. Time till next turn. This sorts the cards as though the patients were in a queue, as those patients who are to be turned soon will be at the top. This feature used MUI's Select component. Filtering A nurse can click the filter icon located in the top right corner of the screen to open the filtering component. This component allows them to filter patients out based on the criteria of Braden Scale value, time since last turn, and stay duration. Braden Scale: filter buckets form the three pressure ulcer risk categories (high, medium, low). Last Turn Time: filter buckets fall in increments of one hour for a total of four buckets. Stay Duration: filter buckets form the four quartiles of the distribution of stay duration amongst all patients. This component can allow nurses to look at a subset of patients based on a variety of different criteria combinations. It uses MUI's Checkbox and Drawer components. Statistics This feature allows nurses to analyze pressure ulcer activity from an ICU-level perspective as a whole. It seeks to provide them with an analysis of the trends occuring in the ICU in order to understand how they might adjust their caretaking based on these numbers. The Statistics feautre consists of three main parts: Median Statistics: reports the median Braden Scale, Stay Duration, and Time Since Last Turned values across the whole ICU. Archive Table: when a patient is deleted, their row from the patient table in the database is moved to a separate \"archive\" table. This way, we can analyze trends amongst those who have completed their ICU stay to understand what their stay was like. Braden Bucket Statistics: buckets each archive patient into a Braden risk category and examines the trends in each bucket. For example, for the patients in the high risk bucket, this feature reports what the average age, weight, stay duration, etc. is. Code for this component can be found in client/stats.jsx , client/bradenBucketStats.jsx , and api/stats.py . It was created using MUI's Dialog and Accordian components. Feedback Form A nurse can click the blue feedback icon on the bottom right corner of the screen if they would like to provide us feedback on the app. When they submit the feedback, it goes straight to our database with a timestamp marking when it was submitted. Code for this component can be found in client/feedbackForm.jsx . Like many of our other components, this one uses MUI's Dialog component. Login and Logout As a method of authentication, we ensure that nurses have the ability to login an logout of the app. Before reading about this component, please make sure you understand how token authentication works from the Architecture section. If the current user is not in possession of a valid token, the login screen with a username and password prompt will appear. The API endpoint servicing logins will first ensure that the credentials entered are correct based on login info stored in the database. Once logged in, the user will acquire a valid token, and can logout using the button at the top left corner of the screen. Logging out will clear the current token. You can find the code for the login component in client/login.jsx and api/login.py .","title":"Components"},{"location":"components/#overview","text":"The following section will discuss the various key components to Alivio's app. At a high level, we will discuss the functionality of each component, their necessity from a user perspective, and how they were built. Before reading this section, we would highly recommend reading the Technologies section to get a feel for which languages and libraries were used in creating the components. Alivio's app serves as a pressure ulcer risk management system. It seeks to help nurses understand the incidence of pressure ulcers in the ICU on a patient-by-patient basis as well as on a population-level basis. Furthermore, the app allows nurses to understand and synthesize patient data relavent to pressure ulcers in order to better inform their decision making when tending to patients and organizing their workflow.","title":"Overview"},{"location":"components/#patient-card","text":"In order to give nurses a \"patient-by-patient\" view, each patient is displayed as a \"card\". Each card can be expanded by clicking the gray arrow at the bottom-center of the card in order to view pressure ulcer related data specfic to the patient. Each patient is uniquely identified by their bed number and ward, which is displayed when the card is both expanded and closed. When expanding the card, a nurse can see the following pieces of data, which were all identified as relavent to pressure ulcers by SAIMER: Age Sex Weight Duration of stay in the ICU Braden Scale value Exact date and time when the patient was last turned Average turn time (i.e. on average, what is the time since the patient was last turned) Notes taken by the nurse These values can be edited by clicking the pencil icon in the top right corner of the expanded portion of the card. The code for the patient card component can be seen in client/patientCard.jsx . The styling is done in client/styles/card.css , and this MUI component. Most of the backend functionalities pertaining to rendering the cards, updating the card's values, adding a new card, etc. live in api/index.py .","title":"Patient Card"},{"location":"components/#patient-card-management","text":"In order to add and delete patient cards, a nurse should first click the pencil icon at the top center of the entire screen (above the fist card displayed, next to the search bar and sorting features) to perform any additions or deletions. To add a new patient, the nurse can click the plus icon and a dialog will pop up listing all the information that will be needed to generate a new card. To delete a patient, the nurse should click the red trash can icon at the top right of the desired patient card. The add patient functionality code can be found in client/addPatient.jsx and all other necessary functionalities for these two components can be found in client/patientCard.jsx . To create the add patient component, MUI's Dialog and DateTimePicker components were used.","title":"Patient Card Management"},{"location":"components/#clock","text":"One of the key features on our patient card is the clock mounted to the right of the patient's bed and ward. Here are they key functionalities of clock: At the center of the ring that represents the clock, the time since the patient was last turned is displayed. The ring \"fills up\" with solid color to denote how close the time to turn the patient again is. When the ring is less than 1/3 full it is green, between 1/3 and 2/3 full it is orange, and more than 2/3 full it is red. The ring fills up at a rate proportional to the patient's Braden Scale value. Based on numbers given to us by SAIMER, a patient at high risk for pressure ulcers needs to be turned every two hours, whereas for medium risk the time is three hours and low risk is two hours. Risk categorization is determined by the creators of the Braden Scale; further information can be found in the Braden Scale link in the card section above. To reset the clock back to 0h0m (i.e. a patient has been turned), a nurse should double tap inside the ring, as indicated by the text below the time. In the event that a nurse accidentally double taps the clock, they can reset back to the original time displayed by double tapping again. There is a thirty second window built in to perform this reset. This clock is a key feature in bringing rich visuals to the app and helping nurses understand where all patients stand at any given moment regarding their turn timing. All front end work for the clock can be found in client/clock.jsx and client/styles/clock.css ; since the clock is a child component of the patient card, state is lifted upwards to the patient card component and therefore other clock functionalities can also be found in client/patientCard.jsx . All backend work currently lives in api/clock.py . The ring component was built using a React package called react-circular-progressbar .","title":"Clock"},{"location":"components/#ulcer-map","text":"When the patient card is expanded, a diagram of two human bodies is displayed below all the data by default. These two diagrams serve as the Ulcer Map component, which is a way for nurses to mark where the given patient has ulcers on their body. In order to mark the ulcers, the nurse would have to click the pencil icon to trigger edit mode and then tap the area of the body where the ulcer is. Then, a red circle will appear there to denote it. If a nurse would like to remove that circle, they can tap the circle and it will disappear. The Ulcer Map is a child component of the patient card and all of its front end code can be found in client/ulcerMap.jsx (as well as client/patientCard.jsx ). The design of the component was inspired by this StackOverflow post and corresponding CodeSandbox. Info Using a CodeSandbox for frontend Javascript work can be really helpful. It provides a way for you to write some code and see how it works in an isolated environment without needing any IDE set up on your end.","title":"Ulcer Map"},{"location":"components/#trends","text":"When the patient card is expanded, there are two icons in the top right corner of the expanded portion when in the default state: a pencil icon (edit mode) and a trend icon. When the trend icon is clicked on, the Ulcer Map changes to the Trends component. When the Trends component is displayed, the trenc icon toggles to a human body icon to toggle back to the Ulcer Map. The Trends component displays a graph of how the patient's Braden Scale value changes over time (tracked in the unit of days). This allows for a nurse to gain a better understanding of a patient's progression regarding pressure ulcers in a visual way. The Trends component is a child component of the patient card and all of its front end code can be found in client/patientStats.jsx (as well as client/patientCard.jsx ). The React graphing library Victory was used to make the chart.","title":"Trends"},{"location":"components/#braden-scale-calculator","text":"In order to actually calculate a patient's Braden Scale value, the Braden Scale Calculator component provides an interface to input the specific values for each category in the scale. The calculator icon, which appears next to the Braden Scale value when edit mode is on, will display the caclulator when clicked. All front end code can be found in client/calculator.jsx , which serves as the base dialog pop up for the component, and client/bradenInputs.jsx . All backend code can be found in api/braden.py . In order to create this component, MUI's Dialog and ToggleButtonGroup components were used. Info If you haven't already learned about what the Braden Scale is at this point, please take the time to do some research and understand it, as it is a key part of our app.","title":"Braden Scale Calculator"},{"location":"components/#view-management","text":"In order to make the interface of all the patient cards more manageable, we provide three different ways to focus in on a subset of patients based on specific characteristics. Code for the search bar and sorting can be found in client/home.jsx and code for filtering can be found in client/filtering.jsx .","title":"View Management"},{"location":"components/#search-bar","text":"A nurse can search for specific patient cards based on the notes in their cards.","title":"Search Bar"},{"location":"components/#sorting","text":"A nurse can sort the cards based on four different criteria: Braden Scale value. This is the default way the cards are sorted, as it places higher risk patients (those with lower Braden Scale values) at the top of the list. Bed. This sorts the cards in ascending order by bed id. Time since last turn. This allows for nurses to see which patients were turned the longest time ago at the top. Time till next turn. This sorts the cards as though the patients were in a queue, as those patients who are to be turned soon will be at the top. This feature used MUI's Select component.","title":"Sorting"},{"location":"components/#filtering","text":"A nurse can click the filter icon located in the top right corner of the screen to open the filtering component. This component allows them to filter patients out based on the criteria of Braden Scale value, time since last turn, and stay duration. Braden Scale: filter buckets form the three pressure ulcer risk categories (high, medium, low). Last Turn Time: filter buckets fall in increments of one hour for a total of four buckets. Stay Duration: filter buckets form the four quartiles of the distribution of stay duration amongst all patients. This component can allow nurses to look at a subset of patients based on a variety of different criteria combinations. It uses MUI's Checkbox and Drawer components.","title":"Filtering"},{"location":"components/#statistics","text":"This feature allows nurses to analyze pressure ulcer activity from an ICU-level perspective as a whole. It seeks to provide them with an analysis of the trends occuring in the ICU in order to understand how they might adjust their caretaking based on these numbers. The Statistics feautre consists of three main parts: Median Statistics: reports the median Braden Scale, Stay Duration, and Time Since Last Turned values across the whole ICU. Archive Table: when a patient is deleted, their row from the patient table in the database is moved to a separate \"archive\" table. This way, we can analyze trends amongst those who have completed their ICU stay to understand what their stay was like. Braden Bucket Statistics: buckets each archive patient into a Braden risk category and examines the trends in each bucket. For example, for the patients in the high risk bucket, this feature reports what the average age, weight, stay duration, etc. is. Code for this component can be found in client/stats.jsx , client/bradenBucketStats.jsx , and api/stats.py . It was created using MUI's Dialog and Accordian components.","title":"Statistics"},{"location":"components/#feedback-form","text":"A nurse can click the blue feedback icon on the bottom right corner of the screen if they would like to provide us feedback on the app. When they submit the feedback, it goes straight to our database with a timestamp marking when it was submitted. Code for this component can be found in client/feedbackForm.jsx . Like many of our other components, this one uses MUI's Dialog component.","title":"Feedback Form"},{"location":"components/#login-and-logout","text":"As a method of authentication, we ensure that nurses have the ability to login an logout of the app. Before reading about this component, please make sure you understand how token authentication works from the Architecture section. If the current user is not in possession of a valid token, the login screen with a username and password prompt will appear. The API endpoint servicing logins will first ensure that the credentials entered are correct based on login info stored in the database. Once logged in, the user will acquire a valid token, and can logout using the button at the top left corner of the screen. Logging out will clear the current token. You can find the code for the login component in client/login.jsx and api/login.py .","title":"Login and Logout"},{"location":"quicklinks/","text":"Overview This page has some useful links for learning technologies that the app uses: General Web Dev Web Dev, w3 schools Not all of this is relevant, the ones that are include HTTP, AJAX, JSON, SQL, AWS Elastic Beanstalk Python and REST APIs: Interacting With Web Services An overview of HTTP - HTTP | MDN EECS 485 Lectures: Panopto Video Lectures 2 - 10 Python Python tutorial The Python Tutorial - Python 3.10.7 documentation The Python Standard Library Flask Flask Tutorial The most important sections in this guide are: Overview Application Routing Variable Rules URL Building HTTP Methods Redirect & Error Quick Start - Flask Documentation JavaScript & React The Modern JavaScript Tutorial Tutorial: Intro to React React Tutorial, w3 schools React JS Crash Course - YouTube AWS Boto3","title":"Quicklinks"},{"location":"quicklinks/#overview","text":"This page has some useful links for learning technologies that the app uses:","title":"Overview"},{"location":"quicklinks/#general-web-dev","text":"Web Dev, w3 schools Not all of this is relevant, the ones that are include HTTP, AJAX, JSON, SQL, AWS Elastic Beanstalk Python and REST APIs: Interacting With Web Services An overview of HTTP - HTTP | MDN EECS 485 Lectures: Panopto Video Lectures 2 - 10","title":"General Web Dev"},{"location":"quicklinks/#python","text":"Python tutorial The Python Tutorial - Python 3.10.7 documentation The Python Standard Library","title":"Python"},{"location":"quicklinks/#flask","text":"Flask Tutorial The most important sections in this guide are: Overview Application Routing Variable Rules URL Building HTTP Methods Redirect & Error Quick Start - Flask Documentation","title":"Flask"},{"location":"quicklinks/#javascript-react","text":"The Modern JavaScript Tutorial Tutorial: Intro to React React Tutorial, w3 schools React JS Crash Course - YouTube","title":"JavaScript &amp; React"},{"location":"quicklinks/#aws","text":"Boto3","title":"AWS"},{"location":"set-up-and-run/","text":"Setup 1. First Installations: Python, git, etc macOS $ brew install python3 java git tree wget $ brew install java WSL/Linux $ sudo apt-get update $ sudo apt-get install python3 python3-pip python3-venv python3-wheel python3-setuptools git tree default-jre 2. Web Dev Specific Installations macOS $ brew install sqlite3 curl coreutils node WSL/Linux $ sudo apt-get install sqlite3 curl nodejs npm 3. Clone the Repo from Github First, make sure you have Github Authentication set up. You can follow this EECS 280 tutorial if you need help, and can choose to use with an SSH key or Personal Access Token (PAT). Warning If you chose to use an SSH key to set up your Github Authentication, there is one more step you must take in order to be able to push and pull from Alivio's repositories. Navigate to Github on your browser, make sure that you are signed in, and go the the settings page. This can be done by clicking your profile icon in the top right corner of the page. Now that you're in your settings, go to the SSH and GPG keys page. Find the key that you're using under the Authentication Keys section. Then, for that particular key, click the Configure SSO button, and allow access to the Project Alivio organization. To clone the repo do one of the following: If you use SSH : $ git clone git@github.com:Project-Alivio/alivio-prioritization.git If you use PAT : $ git clone https://github.com/Project-Alivio/alivio-prioritization.git 4. Alivio Specific Installations First, activate a virtual environment $ python3 -m venv env $ source env/bin/activate Next, install Python packages $ pip install -r requirements.txt $ pre-commit install Then, install the front-end related packages Run: $ npm ci . 5. Set Up .env (Environment) File (NEW FOR THIS YEAR, EVERYONE MUST DO IT) Navigate to the root of the alivio directory if you aren\u2019t already there Run $ touch .env Open the .env file in an IDE like VSCode Add the following environment variables given by Swaraj to the file Warning If you're on Windows/WSL, sometimes copying and pasting from some other file can add hidden characters or mess up the line endings in the .env file. After adding in the appropriate environment variables, run $ dos2unix .env . If you don't have dos2unix installed, run $ sudo apt install dos2unix . 6. IDEs VS Code Optional: DataGrip, this is really useful for running SQL queries Sign up for a JetBrains Education license. Follow the steps that JetBrains outlines as you apply (you\u2019re going to have to activate it through your umich email) When your account is all set up, download DataGrip for your appropriate OS Launch DataGrip and create a new project with whatever name you want On the left hand side of your screen, you\u2019ll see the words \u201cDatabase Explorer\u201d, and there should be a \u201c+\u201d symbol button near it Click the + symbol, then click \u201cData Sources\u201d, and finally click PostgreSQL A dialog box will pop up asking you to fill out the following fields: Name : postgres@AWSRDS Host : alivio-prioritization-db.c4tuxwdpwsfq.us-east-1.rds.amazonaws.com Port : 5432 Authentication : User & Password User : alivio Password : ask Swaraj for this one Database : ebdb URL : jdbc:postgresql://alivio-prioritization-db.c4tuxwdpwsfq.us-east-1.rds.amazonaws.com:5432/ebdb Hit \u201cOK\u201d in the dialog box and then you should see postgres@AWSRDS show up on the left hand side panel. To navigate to our DB tables, hit the drop down arrows on postgres@AWSRDS > ebdb > public > tables If you ever want to run a query, right click on postgres@AWSRDS, hit the \u201cJump to Query Console\u201d option, and then \u201cOpen Default Console\u201d Type whatever query you want and hit the green run button (looks like a play button) 7. Run Running the App on your Browser cd into the project directory Make sure virtual environment is activated Run $ source env/bin/activate Run $ ./bin/alivio start Navigate to localhost:8000 in your browser To create a new branch on git: $ git checkout -b <name_of_branch> 8. Debugging Tips For Python related debugging, using pdb can be helpful. As the linked documentation says, simply import pdb in the Python file you're debugging in and type in the line pdb.set_trace() above where you want to start debugging. pdb.set_trace() now functions as a breakpoint. Once the breakpoint is triggered, look at your terminal (from which the app was run) and you should see that you have entered the pdb console. See the section on debugging commands in the linked documentation to understand how to use pdb. For JavaScript related debugging, using the developer tools in your browser can be helpful. Here, if you navigate to the Sources tab and open the alivio folder in the left side panel and go into the client directory, you should see all of the .jsx source files. You can open up these files, set breakpoints wherever, and have them triggered as you interact with the UX. 9. Managing Node Versions Due to the fact that a significant chunk of Alivio's codebase was written 1.5 years ago, the latest, non-stable builds of Node aren't compatible with the Alivio application. However, if you're using a more recent version of node for another project on your computer, it's worth using nvm to manage changing versions of Node. (For example, taking EECS 485, and also doing Alivio). This section will describe how to download nvm and switch between versions of Node. It is OPTIONAL and only needs to be done if you have issues with Node. Downloading NVM This section is written w/ the assumption that you're using WSL and Bash. If you're on MacOS you'll need to look up how to manage Node versions on MacOS. To install NVM, and set the source lines, run the following commands: $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash $ export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm Then restart your terminal and run $ nvm to verify your installation. Installing and managing Node.js versions To install a Node version, run: $ nvm install --<version number> To see what versions of Node you have, run: $ nvm ls To switch node versions, run: $ nvm use <version number> Repairing a damaged Node installation Again, this section is written for a WSL / Linux User (I don't have a mac) :( $ sudo apt-get update $ sudo apt-get clean $ sudo apt-get autoremove # at this point try and reinstall node / npm again. If it doesn't work continue $ sudo apt --fix-broken install $ sudo apt-get update && sudo apt-get upgrade $ sudo dpkg --configure -a $ sudo apt-get install -f # at this point try and reinstall node / npm again. If it doesn't work continue # check for dependancies using $ sudo dpkg --configure -a # Hopefully you get an empty output here. $ sudo apt-get remove nodejs $ sudo apt-get remove npm # cd to /etc/apt/sources.list.d and remove any node list you have $ cd ~/../../etc/apt/sources.list.d/ # an example path on a standard ubuntu set up # remove any node source list if there exists one. Then do: $ sudo apt-get update # try reinstalling node js and npm again now. # if this doesn't work you're on your own :(","title":"Set Up and Run Tutorial"},{"location":"set-up-and-run/#setup","text":"","title":"Setup"},{"location":"set-up-and-run/#1-first-installations-python-git-etc","text":"macOS $ brew install python3 java git tree wget $ brew install java WSL/Linux $ sudo apt-get update $ sudo apt-get install python3 python3-pip python3-venv python3-wheel python3-setuptools git tree default-jre","title":"1. First Installations: Python, git, etc"},{"location":"set-up-and-run/#2-web-dev-specific-installations","text":"macOS $ brew install sqlite3 curl coreutils node WSL/Linux $ sudo apt-get install sqlite3 curl nodejs npm","title":"2. Web Dev Specific Installations"},{"location":"set-up-and-run/#3-clone-the-repo-from-github","text":"First, make sure you have Github Authentication set up. You can follow this EECS 280 tutorial if you need help, and can choose to use with an SSH key or Personal Access Token (PAT). Warning If you chose to use an SSH key to set up your Github Authentication, there is one more step you must take in order to be able to push and pull from Alivio's repositories. Navigate to Github on your browser, make sure that you are signed in, and go the the settings page. This can be done by clicking your profile icon in the top right corner of the page. Now that you're in your settings, go to the SSH and GPG keys page. Find the key that you're using under the Authentication Keys section. Then, for that particular key, click the Configure SSO button, and allow access to the Project Alivio organization. To clone the repo do one of the following: If you use SSH : $ git clone git@github.com:Project-Alivio/alivio-prioritization.git If you use PAT : $ git clone https://github.com/Project-Alivio/alivio-prioritization.git","title":"3. Clone the Repo from Github"},{"location":"set-up-and-run/#4-alivio-specific-installations","text":"First, activate a virtual environment $ python3 -m venv env $ source env/bin/activate Next, install Python packages $ pip install -r requirements.txt $ pre-commit install Then, install the front-end related packages Run: $ npm ci .","title":"4. Alivio Specific Installations"},{"location":"set-up-and-run/#5-set-up-env-environment-file-new-for-this-year-everyone-must-do-it","text":"Navigate to the root of the alivio directory if you aren\u2019t already there Run $ touch .env Open the .env file in an IDE like VSCode Add the following environment variables given by Swaraj to the file Warning If you're on Windows/WSL, sometimes copying and pasting from some other file can add hidden characters or mess up the line endings in the .env file. After adding in the appropriate environment variables, run $ dos2unix .env . If you don't have dos2unix installed, run $ sudo apt install dos2unix .","title":"5. Set Up .env (Environment) File (NEW FOR THIS YEAR, EVERYONE MUST DO IT)"},{"location":"set-up-and-run/#6-ides","text":"VS Code Optional: DataGrip, this is really useful for running SQL queries Sign up for a JetBrains Education license. Follow the steps that JetBrains outlines as you apply (you\u2019re going to have to activate it through your umich email) When your account is all set up, download DataGrip for your appropriate OS Launch DataGrip and create a new project with whatever name you want On the left hand side of your screen, you\u2019ll see the words \u201cDatabase Explorer\u201d, and there should be a \u201c+\u201d symbol button near it Click the + symbol, then click \u201cData Sources\u201d, and finally click PostgreSQL A dialog box will pop up asking you to fill out the following fields: Name : postgres@AWSRDS Host : alivio-prioritization-db.c4tuxwdpwsfq.us-east-1.rds.amazonaws.com Port : 5432 Authentication : User & Password User : alivio Password : ask Swaraj for this one Database : ebdb URL : jdbc:postgresql://alivio-prioritization-db.c4tuxwdpwsfq.us-east-1.rds.amazonaws.com:5432/ebdb Hit \u201cOK\u201d in the dialog box and then you should see postgres@AWSRDS show up on the left hand side panel. To navigate to our DB tables, hit the drop down arrows on postgres@AWSRDS > ebdb > public > tables If you ever want to run a query, right click on postgres@AWSRDS, hit the \u201cJump to Query Console\u201d option, and then \u201cOpen Default Console\u201d Type whatever query you want and hit the green run button (looks like a play button)","title":"6. IDEs"},{"location":"set-up-and-run/#7-run","text":"Running the App on your Browser cd into the project directory Make sure virtual environment is activated Run $ source env/bin/activate Run $ ./bin/alivio start Navigate to localhost:8000 in your browser To create a new branch on git: $ git checkout -b <name_of_branch>","title":"7. Run"},{"location":"set-up-and-run/#8-debugging-tips","text":"For Python related debugging, using pdb can be helpful. As the linked documentation says, simply import pdb in the Python file you're debugging in and type in the line pdb.set_trace() above where you want to start debugging. pdb.set_trace() now functions as a breakpoint. Once the breakpoint is triggered, look at your terminal (from which the app was run) and you should see that you have entered the pdb console. See the section on debugging commands in the linked documentation to understand how to use pdb. For JavaScript related debugging, using the developer tools in your browser can be helpful. Here, if you navigate to the Sources tab and open the alivio folder in the left side panel and go into the client directory, you should see all of the .jsx source files. You can open up these files, set breakpoints wherever, and have them triggered as you interact with the UX.","title":"8. Debugging Tips"},{"location":"set-up-and-run/#9-managing-node-versions","text":"Due to the fact that a significant chunk of Alivio's codebase was written 1.5 years ago, the latest, non-stable builds of Node aren't compatible with the Alivio application. However, if you're using a more recent version of node for another project on your computer, it's worth using nvm to manage changing versions of Node. (For example, taking EECS 485, and also doing Alivio). This section will describe how to download nvm and switch between versions of Node. It is OPTIONAL and only needs to be done if you have issues with Node.","title":"9. Managing Node Versions"},{"location":"set-up-and-run/#downloading-nvm","text":"This section is written w/ the assumption that you're using WSL and Bash. If you're on MacOS you'll need to look up how to manage Node versions on MacOS. To install NVM, and set the source lines, run the following commands: $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash $ export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm Then restart your terminal and run $ nvm to verify your installation.","title":"Downloading NVM"},{"location":"set-up-and-run/#installing-and-managing-nodejs-versions","text":"To install a Node version, run: $ nvm install --<version number> To see what versions of Node you have, run: $ nvm ls To switch node versions, run: $ nvm use <version number>","title":"Installing and managing Node.js versions"},{"location":"set-up-and-run/#repairing-a-damaged-node-installation","text":"Again, this section is written for a WSL / Linux User (I don't have a mac) :( $ sudo apt-get update $ sudo apt-get clean $ sudo apt-get autoremove # at this point try and reinstall node / npm again. If it doesn't work continue $ sudo apt --fix-broken install $ sudo apt-get update && sudo apt-get upgrade $ sudo dpkg --configure -a $ sudo apt-get install -f # at this point try and reinstall node / npm again. If it doesn't work continue # check for dependancies using $ sudo dpkg --configure -a # Hopefully you get an empty output here. $ sudo apt-get remove nodejs $ sudo apt-get remove npm # cd to /etc/apt/sources.list.d and remove any node list you have $ cd ~/../../etc/apt/sources.list.d/ # an example path on a standard ubuntu set up # remove any node source list if there exists one. Then do: $ sudo apt-get update # try reinstalling node js and npm again now. # if this doesn't work you're on your own :(","title":"Repairing a damaged Node installation"},{"location":"stack/","text":"Overview This section provides an overview of Alivio's stack: the different programming languages, libraries, frameworks, and cloud services that we use to build the app. When designing a new feature, we require that you stay consistent with the current stack that we have and document any new additions if needed. Front End Programming Language : JavaScript, HTML, CSS Frameworks : React.js Third Party React Libraries Material UI (MUI): Styling moment.js: Used for dealing with datetime data Victory: Used for making charts Module bundler : webpack Back End Programming Language : Python Web Framework : Flask Helps develop REST API endpoints. Third Party Libraries : see our requirements.txt file. Some important libraries include: boto3: Used in model.py for interfacing with AWS database psycopg2: Used in model.py to make PostgreSQL queries Database Database Language : PostgreSQL Cloud Deployment Containerization : Docker / AWS Elastic Container Registry Load Balancing : Elastic Beanstalk, Elastic Compute Cloud Security : AWS Web Application Firewall","title":"Technology Stack"},{"location":"stack/#overview","text":"This section provides an overview of Alivio's stack: the different programming languages, libraries, frameworks, and cloud services that we use to build the app. When designing a new feature, we require that you stay consistent with the current stack that we have and document any new additions if needed.","title":"Overview"},{"location":"stack/#front-end","text":"Programming Language : JavaScript, HTML, CSS Frameworks : React.js Third Party React Libraries Material UI (MUI): Styling moment.js: Used for dealing with datetime data Victory: Used for making charts Module bundler : webpack","title":"Front End"},{"location":"stack/#back-end","text":"Programming Language : Python Web Framework : Flask Helps develop REST API endpoints. Third Party Libraries : see our requirements.txt file. Some important libraries include: boto3: Used in model.py for interfacing with AWS database psycopg2: Used in model.py to make PostgreSQL queries","title":"Back End"},{"location":"stack/#database","text":"Database Language : PostgreSQL","title":"Database"},{"location":"stack/#cloud-deployment","text":"Containerization : Docker / AWS Elastic Container Registry Load Balancing : Elastic Beanstalk, Elastic Compute Cloud Security : AWS Web Application Firewall","title":"Cloud Deployment"},{"location":"workflow/","text":"Overview This section will discussion basic git workflow for contributing to the application. In general when adding a new feature, you want to follow these steps: Create a new branch. Work on your feature Once you are done create a pull request to merge the branch into main, specify 2 reviewers. Branches To make a new branch and then switch to it you can do either of these: $ git branch <new_branch_name> $ git checkout <new_branch_name> OR $ git checkout -b <new_branch_name> Pull Requests When a feature is finished, we want to merge the code / content on the new branch back into main. Since the main branch is protected, don't attempt to directly merge the main branch with yours. Instead, push your changes to the remote and create a pull request. To create the PR do the following: Ensure your branch is up to date and you've pushed all the changes that you want to merge to the remote Open the Project-Alivio/alivio-prioritization page At the top-bar click on the Pull request button. Hit New pull request , and add 2 reviewers. Add one older member of the team and one newer member if possible. Done! What to check as a reviewer The motivation of having PRs is that everyone gets exposure to various parts of the app. This should help us all stay moderately familiar with different app components. It also helps us maintain code quality. As a reviewer look out for the following: Clean code style Proper commenting when necessary Code correctness Error handling / edge cases Performance considerations Merge conflicts In the event of merge conflicts do the following: Open the files with conflicts, merge the code as desired. Once code has been merged, save the files and git add them. Make a new \"merge commit\" to finalize the merge Done! Prettier / Precommits We use a linter called Prettier to run pre-commit formatting of code style. When you attempt to commit code, a git hook will run which will check your code for style. The purpose of this is for us to maintain a uniformly styled, easily readable repository. If your code fails the linter, you'll be given a descriptive message of what to fix and the commit will be aborted. Then, once you make the changes required by the linter you can re-commit.","title":"Workflow"},{"location":"workflow/#overview","text":"This section will discussion basic git workflow for contributing to the application. In general when adding a new feature, you want to follow these steps: Create a new branch. Work on your feature Once you are done create a pull request to merge the branch into main, specify 2 reviewers.","title":"Overview"},{"location":"workflow/#branches","text":"To make a new branch and then switch to it you can do either of these: $ git branch <new_branch_name> $ git checkout <new_branch_name> OR $ git checkout -b <new_branch_name>","title":"Branches"},{"location":"workflow/#pull-requests","text":"When a feature is finished, we want to merge the code / content on the new branch back into main. Since the main branch is protected, don't attempt to directly merge the main branch with yours. Instead, push your changes to the remote and create a pull request. To create the PR do the following: Ensure your branch is up to date and you've pushed all the changes that you want to merge to the remote Open the Project-Alivio/alivio-prioritization page At the top-bar click on the Pull request button. Hit New pull request , and add 2 reviewers. Add one older member of the team and one newer member if possible. Done!","title":"Pull Requests"},{"location":"workflow/#what-to-check-as-a-reviewer","text":"The motivation of having PRs is that everyone gets exposure to various parts of the app. This should help us all stay moderately familiar with different app components. It also helps us maintain code quality. As a reviewer look out for the following: Clean code style Proper commenting when necessary Code correctness Error handling / edge cases Performance considerations","title":"What to check as a reviewer"},{"location":"workflow/#merge-conflicts","text":"In the event of merge conflicts do the following: Open the files with conflicts, merge the code as desired. Once code has been merged, save the files and git add them. Make a new \"merge commit\" to finalize the merge Done!","title":"Merge conflicts"},{"location":"workflow/#prettier-precommits","text":"We use a linter called Prettier to run pre-commit formatting of code style. When you attempt to commit code, a git hook will run which will check your code for style. The purpose of this is for us to maintain a uniformly styled, easily readable repository. If your code fails the linter, you'll be given a descriptive message of what to fix and the commit will be aborted. Then, once you make the changes required by the linter you can re-commit.","title":"Prettier / Precommits"}]}